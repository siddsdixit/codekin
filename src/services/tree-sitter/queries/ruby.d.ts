declare const _default: "\n; Method definitions\n(method\n  name: (identifier) @name.definition.method) @definition.method\n\n; Singleton methods\n(singleton_method\n  object: (_)\n  name: (identifier) @name.definition.method) @definition.method\n\n; Method aliases\n(alias\n  name: (_) @name.definition.method) @definition.method\n\n; Class definitions\n(class\n  name: [\n    (constant) @name.definition.class\n    (scope_resolution\n      name: (_) @name.definition.class)\n  ]) @definition.class\n\n; Singleton classes\n(singleton_class\n  value: [\n    (constant) @name.definition.class\n    (scope_resolution\n      name: (_) @name.definition.class)\n  ]) @definition.class\n\n; Module definitions\n(module\n  name: [\n    (constant) @name.definition.module\n    (scope_resolution\n      name: (_) @name.definition.module)\n  ]) @definition.module\n\n; Constants\n(assignment\n  left: (constant) @name.definition.constant) @definition.constant\n\n; Global variables\n(global_variable) @definition.global_variable\n\n; Instance variables\n(instance_variable) @definition.instance_variable\n\n; Class variables\n(class_variable) @definition.class_variable\n\n; Symbols\n(simple_symbol) @definition.symbol\n(hash_key_symbol) @definition.symbol\n\n; Blocks\n(block) @definition.block\n(do_block) @definition.block\n\n; Basic mixin statements - capture all include/extend/prepend calls\n(call\n  method: (identifier) @_mixin_method\n  arguments: (argument_list\n    (constant) @name.definition.mixin)\n  (#match? @_mixin_method \"^(include|extend|prepend)$\")) @definition.mixin\n\n; Mixin module definition\n(module\n  name: (constant) @name.definition.mixin_module\n  (#match? @name.definition.mixin_module \".*Module$\")) @definition.mixin_module\n\n; Mixin-related methods\n(method\n  name: (identifier) @name.definition.mixin_method\n  (#match? @name.definition.mixin_method \"(included|extended|prepended)_method\")) @definition.mixin_method\n\n; Singleton class blocks\n(singleton_class) @definition.singleton_class\n\n; Class methods in singleton context\n(singleton_method\n  object: (self)\n  name: (identifier) @name.definition.singleton_method) @definition.singleton_method\n\n; Attribute accessors\n(call\n  method: (identifier) @_attr_accessor\n  arguments: (argument_list\n    (_) @name.definition.attr_accessor)\n  (#eq? @_attr_accessor \"attr_accessor\")) @definition.attr_accessor\n\n(call\n  method: (identifier) @_attr_reader\n  arguments: (argument_list\n    (_) @name.definition.attr_reader)\n  (#eq? @_attr_reader \"attr_reader\")) @definition.attr_reader\n\n(call\n  method: (identifier) @_attr_writer\n  arguments: (argument_list\n    (_) @name.definition.attr_writer)\n  (#eq? @_attr_writer \"attr_writer\")) @definition.attr_writer\n\n; Class macros (Rails-like)\n(call\n  method: (identifier) @_macro_name\n  arguments: (argument_list\n    (_) @name.definition.class_macro)\n  (#match? @_macro_name \"^(has_many|belongs_to|has_one|validates|scope|before_action|after_action)$\")) @definition.class_macro\n\n; Exception handling\n(begin) @definition.begin\n(rescue) @definition.rescue\n(ensure) @definition.ensure\n\n; Keyword arguments\n(keyword_parameter\n  name: (identifier) @name.definition.keyword_parameter) @definition.keyword_parameter\n\n; Splat operators\n(splat_parameter) @definition.splat_parameter\n(splat_argument) @definition.splat_argument\n\n; Hash syntax variants\n(pair\n  key: (_) @name.definition.hash_key) @definition.hash_pair\n\n; String interpolation - capture the string with interpolation and surrounding context\n(assignment\n  left: (identifier) @name.definition.string_var\n  right: (string\n    (interpolation))) @definition.string_interpolation\n\n; Regular expressions - capture the regex pattern and assignment\n(assignment\n  left: (identifier) @name.definition.regex_var\n  right: (regex)) @definition.regex_assignment\n\n; Pattern matching - capture the entire case_match structure\n(case_match) @definition.case_match\n\n; Pattern matching - capture in_clause with hash pattern\n(in_clause\n  pattern: (hash_pattern)) @definition.hash_pattern_clause\n\n; Endless methods - capture the method definition with name and surrounding context\n(comment) @_endless_method_comment\n(#match? @_endless_method_comment \"Ruby 3.0\\+ endless method\")\n(method\n  name: (identifier) @name.definition.endless_method\n  body: (binary\n    operator: \"=\")) @definition.endless_method\n\n; Pin operator - capture the entire in_clause with variable_reference_pattern\n(in_clause\n  pattern: (variable_reference_pattern)) @definition.pin_pattern_clause\n\n; Shorthand hash syntax - capture the method containing shorthand hash\n(comment) @_shorthand_hash_comment\n(#match? @_shorthand_hash_comment \"Ruby 3.1\\+ shorthand hash syntax\")\n(method\n  name: (identifier) @name.definition.shorthand_method) @definition.shorthand_method\n\n; Shorthand hash syntax - capture the hash with shorthand syntax\n(hash\n  (pair\n    (hash_key_symbol)\n    \":\")) @definition.shorthand_hash\n\n; Capture larger contexts for features that need at least 4 lines\n\n; Capture the entire program to include all comments and code\n(program) @definition.program\n\n; Capture all comments\n(comment) @definition.comment\n\n; Capture all method definitions\n(method) @definition.method_all\n";
export default _default;
//# sourceMappingURL=ruby.d.ts.map